-#
  EMBEDDED_STYLE
    #help_button{
      float: right
      margin-top: 50px
    }
    .add_image{
      width: 24px;
      height: 24px;
      clear: right;
    }
    .add_text{
      font-size: 1em;
    }
    
    table a.remove_body{
      font-size: 1em;
      color: inherit;
      text-decoration: none;
    }
    
    table a.remove_body:hover{
      color: lightgrey;
      
    }
    
    #bodies table td, #bodies table th{
      margin-bottom: 2px;
      color: grey;
      
    }
    
    #bodies table tbody tr td input{
      min-width: 40px; 
      width: 40px;
      font-size: inherit;
    }
    
    th.tlabel{
      border-right: solid 1px lightgrey;
      margin-right: 50px;
      min-width: 80px;
      width: 80px;
      max-width: 80px;
      padding: 2px;
      
    }
    
    tr td.first_cell, tr th.first_cell{
      //background: yellow;
      padding-left: 20px; 
    }
    
    tr td:first{
      border: solid;
    }
    
    

    
    .editor_option{
      margin-top: 10px;
      padding-top: 10px;
      border-top: solid lightgray 1px;
    }
    .editor_option > *{
      margin-top: 10px;
      font-size: 0.8em;  
    }
    .editor_option span{
      padding-left: 5px;
      padding-right: 5px;
    }
    
    .editor_option input{
      height: 0.9em;
      
    }

    
  
  EMBEDDED_STYLE



%form#partial_form.panel_in_tab
 
      
  #mesh_params.group
    .group_title
      Mesh
    .prop_row
      .label
        NX
      .field
        %input{:type => "text", :id=>"nx", :valid_if => "divisibleBy4(x)"}
      .long_desc
        Mesh points in x-direction.
    .prop_row
      .label
        NY
      .field
        %input{:type => "text", :id=>"ny", :valid_if => "divisibleBy4(x)"}
      .long_desc
        Mesh points in y-direction.
    .prop_row
      .label
        NZ
      .field
        %input{:type => "text", :id=>"nz", :valid_if => "divisibleBy4(x)"}
      .long_desc
        Mesh points in z-direction.
          
    .prop_row
      .label
        distance
      .field
        %input{:type => "text", :id=>"hr", :valid_if => "isNumber(x)"}  
      .long_desc
        Discretization in coordinate space (distance of mesh points). The same value is used in all
        three directions.
              
    .prop_row
      .label
        maximum iterations
      .field
        %input{:type => "text", :id=>"maxim", :valid_if => "isNumber(x)"}  
      .long_desc
        Maximum number of imaginary timestep iterations.
      
    .prop_row
      .label
        number of states
      .field
        %input{:type => "text", :id=>"morb", :valid_if => "isNumber(x)"}  
      .long_desc
        Number of states that are propagated. This number may be larger than the number of states calculated to improve convergence.

    .prop_row
      .label
        order
      .field
        %input{:type => "text", :id=>"order", :valid_if => "isNumber(x)"}  
      .long_desc
        Order of the finite-difference approximation of the Laplacian.
        
    .prop_row
      .label
        multiplicator
      .field
        %input{:type => "text", :id=>"rmul", :valid_if => "isNumber(x)", :value=>"0.5"}  
      .long_desc
        Multiplicator of timestep ramp.
        
    .prop_row
      .label
        convergence factor(estp)
      .field
        %input{:type => "text", :id=>"estp", :valid_if => "isNumber(x)"}  
      .long_desc
        Convergence factor of the imaginary timestep iterations. This is the value at which the
        iterations start.
        
    .prop_row
      .label
        convergence factor(este)
      .field
        %input{:type => "text", :id=>"este", :valid_if => "isNumber(x)"}  
      .long_desc
        Convergence factor of the imaginary timestep iterations. This is the smallest value that is
        used during the iterations. Setting ESTE = 0 will decrease the time step until the accuracy
        limit determined by EPSR has been reached.
        
    .prop_row
      .label
        converged errors 
      .field
        %input{:type => "checkbox", :id=>"imsg_0"}
      .long_desc
        Show errors and timings after each converged time step.
        
    .prop_row
      .label
        imaginary errors
      .field
        %input{:type => "checkbox", :id=>"imsg_1"}
      .long_desc
        Show errors and timing after each imaginary timestep iteration.
        
    .prop_row
      .label
        timings
      .field
        %input{:type => "checkbox", :id=>"imsg_2"}
      .long_desc
        Show timings.
      
    .prop_row
      .label
        dump
      .field
        %input{:type => "checkbox", :id=>"imsg_3"}
      .long_desc
        Dump eigenvalues and wave functions into a binary data file. 
        Depending on the grid, this may generate a huge file. 
        Meant for testing, documentation, and further processing. 
        The file name is configured in prefix.model.
        
    .prop_row
      .label
        many
      .field
        %input{:type => "text", :id=>"many", :valid_if => "isNumber(x)"}  
      .long_desc
        If this is specified, then the “any-order”
        algorithm with order = 2 × MANY is selected.
        
    .prop_row
      .label
        epsi
      .field
        %input{:type => "text", :id=>"epsi", :valid_if => "isNumber(x)"}  
      .long_desc
        Desired limit for the variance of the overlap energies during the iterations at fixed time step


    .prop_row
      .label
        epsr
      .field
        %input{:type => "text", :id=>"epsr", :valid_if => "isNumber(x)"}  
      .long_desc
        Desired accuracy for the variance of the energy as a function of time step.

  #model_params.group
    .group_title
      Model
    .prop_row
      .label
        h/2m
      .field
        %input{:type => "text", :id=>"h2m", :valid_if => "divisibleBy4(x)"}
      .long_desc
        Value of h/2m. Can be used to set the unit system to atomic Rydberg or Hartree units, but also to 2m
        use an effective mass.

    .prop_row
      .label
        norb
      .field
        %input{:type => "text", :id=>"norb", :valid_if => "divisibleBy4(x)"}
      .long_desc
        Number of states that are converged to the desired accuracy.

  #potential_params.group
    .group_title
      Potential
      %ul#potential_tabs.group_title_tabs
        %li.tab
          %a{:href => '#bodies_panel' }
            bodies
        -#%li.tab
          %a{:href => '#file_panel' }
            file upload
        %li.tab
          %a{:href => '#reference_panel'}
            file reference

    #bodies_panel.tabpanel
      #bodies
      .prop_row
        .label
          default value
        .field
          %input{:type => "text", :id=>"default", :valid_if => "isNumber(x)"}

      .prop_row
        .label
          .add_text
            add
        .field
          %a.action_link{:onClick => "addBody('sphere');"}
            sphere
          %a.action_link{:onClick => "addBody('box');"}
            box
          %a.action_link{:onClick => "addBody('cylinder');"}
            cylinder
          %a.action_link{:onClick => "addBody('halfspace');"}
            halfspace
          %a.action_link{:onClick => "addBody('atom');"}
            atom
    
      .prop_row
        .label
          upload atoms
        .field.upload_box
          %iframe.upload_iframe{:src => '/upload', :scrolling => 'no'}
      .prop_row
        .label
          export
        .field
          %a.action_link{:onClick => "generateX3D(event)"}
            open model
      .prop_row
        .label
          auto distance on/off
        .field
          %input{:type => 'checkbox', :checked => 'checked', :id=>"auto_distance_switch", :onClick => "checkAutoDistance(event)"}

       
            


        
    
    .prop_row.hidden_prototype 
      %table#sphere_prototype
        %tr
          %th{:rowspan => '3', :class => 'tlabel'}
            sphere
          %th.first_cell       
            %span<
              x
            %sub<>
              0
          %th
            %span<
              y
            %sub<>
              0 
          %th
            %span<
              z
            %sub<>
              0
          %th
            r
          %th
            V
          %th
        
        
        %tr 
          %td.first_cell
            %input{:type => 'text', :id => 'sphere_x0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'sphere_y0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'sphere_z0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'sphere_r_prototype', :value => '1'}
          %td
            %input{:type => 'text', :id => 'sphere_v_prototype', :value => '0'}
          %td
            %a.clickable.minus{:onClick => "removeBody(event);"}
    
     
      %table#atom_prototype
        %tr
          %th{:rowspan => '3', :class => 'tlabel'}
            atom
          %th.first_cell       
            %span<
              x
            %sub<>
              0
          %th
            %span<
              y
            %sub<>
              0 
          %th
            %span<
              z
            %sub<>
              0
          %th
            type
          %th


        %tr 
          %td.first_cell
            %input{:type => 'text', :id => 'atom_x0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'atom_y0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'atom_z0_prototype', :value => '0'}
          %td
            %select{:id => 'atom_select_prototype'}
          %td
            %a.clickable.minus{:onClick => "removeBody(event);"}
              
      %table#multiatom_prototype
        %tr
          %th{:rowspan => '2', :class => 'tlabel'}
            atoms
          %th.first_cell       
            Number of atoms
            %input{:type => 'hidden', :id => 'multiatom_coords_prototype'}
          %th


        %tr 
          %td.first_cell#multiatom_no_atoms_prototype
            0
          %td
            %a.clickable.minus{:onClick => "removeBody(event);"}              

      %table#box_prototype
        %tr
          %th.tlabel{:rowspan => '5'}
            rectangular box

          %th.first_cell       
            %span<
              x
            %sub<>
              0
          %th
            %span<
              y
            %sub<>
              0 
          %th
            %span<
              z
            %sub<>
              0
          %th
            width
          %th
            height
          %th
            depth
          %th
    
        %tr 
          %td.first_cell
            %input{:type => 'text', :id => 'box_x0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'box_y0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'box_z0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'box_width_prototype', :value => '2'}
          %td
            %input{:type => 'text', :id => 'box_height_prototype', :value => '2'}
          %td
            %input{:type => 'text', :id => 'box_depth_prototype', :value => '2'}
          %td
            %a.clickable.minus{:onClick => "removeBody(event);"}
              
        %tr
          %th.first_cell
            &theta;
          %th
            &phi;
          %th
            V
        %tr
          %td.first_cell
            %input{:type => 'text', :id => 'box_theta_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'box_phi_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'box_v_prototype', :value => '0'}
            
            
            
      %table#cylinder_prototype
        %tr
          %th.tlabel{:rowspan => '3'}
            cylinder

          %th.first_cell       
            %span<
              x
            %sub<>
              0
          %th
            %span<
              y
            %sub<>
              0 
          %th
            %span<
              z
            %sub<>
              0
          %th
            %span<
              r
          %th
            %span<
              h         
          %th
            &theta;
          %th
            &phi;
          %th
            V
          %th

        %tr 
          %td.first_cell
            %input{:type => 'text', :id => 'cylinder_x0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'cylinder_y0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'cylinder_z0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'cylinder_r_prototype', :value => '1'}
          %td
            %input{:type => 'text', :id => 'cylinder_h_prototype', :value => '2'}
            
          %td
            %input{:type => 'text', :id => 'cylinder_theta_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'cylinder_phi_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'cylinder_v_prototype', :value => '0'}
          %td
            %a.clickable.minus{:onClick => "removeBody(event);"}
      
      %table#halfspace_prototype
        %tr
          %th.tlabel{:rowspan => '400'}
            halfspace

          %th.first_cell       
            %span<
              x
            %sub<>
              0
          %th
            %span<
              y
            %sub<>
              0 
          %th
            %span<
              z
            %sub<>
              0
          %th       
            &theta;
          %th
            &phi;         
          %th
            V
          %th

        %tr 
          %td.first_cell
            %input{:type => 'text', :id => 'halfspace_x0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'halfspace_y0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'halfspace_z0_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'halfspace_theta_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'halfspace_phi_prototype', :value => '0'}
          %td
            %input{:type => 'text', :id => 'halfspace_v_prototype'}
          %td
            %a.clickable.minus{:onClick => "removeBody(event);"}
        %tr
          %td{:colspan => 100}
            .editor_option
              %span
                %span
                  shown as two disks with radius
                %input{:type => 'text', :id => 'halfspace_diskradius_prototype', :value => '100'}
                %span
                  &amp; width
                %input{:type => 'text', :id => 'halfspace_diskwidth_prototype', :value => '1e-15'}
            
            
      
                 
    -#file_panel.tabpanel
      .prop_row
        .label
          file
        .field
          %input{:type => 'file', :id => 'potencial_file'}
        .long_desc
          Only if < 5 MB 
    #reference_panel.tabpanel
      .prop_row
        .label
          file reference
        .field
          %input{:type => "text", :id => 'potential_reference'} 
        .long_desc
          For large files (> 5 MBs) an URL can be given
              
              
  %br 
  
  %X3D#renderer{:height => "650px", :showstat => "false", :width => "650px", :x => "0px", :y => "0px"}
    %Scene
      %Background{:def => "bgnd", :transparency => "1.0"}
      %Viewpoint#main_view{:position => '4.88104 4.59865 7.4181', :orientation => '-0.69017 0.723467 -0.0161809 0.735134'}
      
      
      %Transform{:translation => "0 5 0"}
        %Shape
          %Appearance
            %Material{:diffuseColor => "0 1 0"}
          %Sphere{:radius => "0.05"}
          %Cylinder{:height => "10", :radius => "0.01"}
      %Transform{:rotation => "1 0 0 #{Math::PI/2}", :translation => "0 0 5"} 
        %Shape
          %Appearance
            %Material{:diffuseColor => "0 0 1"}
          %Cylinder{:height => "10", :radius => "0.01"}
      %Transform{:rotation => "0 0 1 #{Math::PI/2}", :translation => "5 0 0"}
        %Shape
          %Appearance
            %Material{:diffuseColor => "1 0 0"}
          %Cylinder{:height => "10", :radius => "0.01"}
           
      %Group#root
      

  #x3dlink
      
      
%form{:id => 'temp_upload'}
  %input#temp_upload_input{:type => :hidden, :name => 'temp_upload_input' } 
  %input#ext{:type => :hidden, :name => 'ext', :value => '.x3d' }  
  
:javascript 

  var NL = "\n"

  document.observe('mousemove', function(event){
    debug($('main_view').getAttribute('position') + "/" + $('main_view').getAttribute('orientation')  +  "[" + event.clientX + "," + event.clientY + "]")
  })

  function addDownloadLink(id){
    var url = '/tmp/' + id
    // $('x3dlink').appendChild(NodeBuilder(
    //   ["a", {href: url, target: "_blank" },
    //     "download file"
    //   ]
    // ))
    window.open(url,"x3dmodel_window");
  }

  function generateX3D(event){
    
    var xml = '<?xml version="1.0" encoding="UTF-8"?>\n' + xml2Str($('renderer'))
      .gsub(/(<\/?)(\S)/, function(match){return match[1] + match[2].capitalize()})
      .gsub("X3d", "X3D")
      .gsub(/xmlns=('|")[^\1]+?\1/, "");
    
    //var dataref = "data:model/x3d+xml;base64," + toBase64(xml)
    //var dataref = "data:model/x3d+xml;charset=utf-8," + xml
    
    //window.open(dataref,"mywindow");
    
    // $('x3dlink').appendChild(NodeBuilder(
    //   ["a", {href: dataref},
    //     "click"
    //   ]
    // ))
    
    $('temp_upload_input').value = xml
    var params = Form.serialize($('temp_upload'))
    new Ajax.Request('/upload/create_temp', {asynchronous:false, evalScripts:true, parameters:params}); return false;
    
  }

  function file_upload(result){
    //alert(result);
    if(result !== ''){
      addUploadedAtoms(result);
    }
  }

  var ATOMS = [
    {id: 'oxigen', gauss: [[0.1,2],[3,4],[5,6]]}, 
    {id: 'coal', gauss: [[0.7,8],[9,10],[11,12]]}    
  ];
  
  var atom_dictionary = [];
  
  function generateAtomOptions(){
    ATOMS.sortBy(function(e){
      return e.id;
    }).each(function (e){
      $w('atom_select_prototype').each(function(item){
        $(item).appendChild(NodeBuilder(['option', {value: e.id}, e.id]));
      });
      atom_dictionary[e.id] = e;
    })
    
  }

  function centerCoords(prefix, index){
    return pointCoords(prefix, "0", index);
  }
  
  function pointCoords(prefix, postfix, index){
    return $w('x y z').map(function(axisName){
      return (+$(prefix + "_" + axisName + postfix + "_" + index).value);
    });    
  }
 
  function addBody(prototype_id, call){
    var editorId = addBodyEditor(prototype_id);
    var editor = $(editorId)
    $(editorId).createX3D = function(){
      //dont use editorId directly because it may change but the closure remembers the old one
      eval('createX3D_' + prototype_id).apply({}, [editor.id]);
    }
    $(editorId).potentialText = function(){
      return eval('potential4_' + prototype_id).apply(this)
    }
    if(call === undefined || call){
      $(editorId).createX3D();
    }
    return editorId;
  }
  
  
  function potential4_sphere(){
    var index = getIndex(this.id);
    var r = $("sphere_r_" + index).value;
    var result = objectsPotentialText(this, 'sphere', "1 " + r )
    return result;
  }
    
  function createX3D_sphere(editorId){
    var transformAttrs = {};
    
    var index = getIndex(editorId);
    var r = $("sphere_r_" + index).value;
    var v = $("sphere_v_" + index).value;
    
    createX3DNode(editorId, 'sphere', transformAttrs, {radius: r});
  }
  
  function boxSizeArray(index){
    return $w("width height depth").map(function(dim){return +$F("box_" + dim + "_" + index)}).join(' ');
  }
  
  function potential4_box(){
    var index = getIndex(this.id);
    var result = objectsPotentialText(this, 'box', "3 " + boxSizeArray(index))
    return result;
  }
  
  function createX3D_box(editorId){
    var transformAttrs = {}
    
    var index = getIndex(editorId)
    var size = boxSizeArray(index)
    
    setRotationBySpherical('box', index, transformAttrs)
    
    createX3DNode(editorId, 'box', transformAttrs, {size: size});
  }
  
  
  
  function potential4_cylinder(){
    var index = getIndex(this.id);
    var r = +$F("cylinder_r_" + index);
    var height = +$F('cylinder_h_' + index);
    var result = objectsPotentialText(this, 'cylinder', [2, r, height].join(' '))
    return result;
  }
  
  function createX3D_cylinder(editorId){
    var transformAttrs = {}
    
    var index = getIndex(editorId)
    var r = +$F("cylinder_r_" + index);
    var height = +$F('cylinder_h_' + index);
    setRotationBySpherical('cylinder', index, transformAttrs)
    createX3DNode(editorId, 'cylinder', transformAttrs, {radius: r, height: height});
  }
  
  function potential4_halfspace(){
    var index = getIndex(this.id);
    var result = objectsPotentialText(this, 'halfspace', '0')
    return result; 
  }
  
  
  function createX3D_halfspace(editorId){
    
    var index = getIndex(editorId)
    var width = +$('halfspace_diskwidth_' + index).value
    var transformAttrs = {translation: "0 " + width/2 + " 0"}
    
    var radius = +$('halfspace_diskradius_' + index).value
    
    setRotationBySpherical('halfspace', index, transformAttrs)
    
    createX3DNode(editorId, 'cylinder', transformAttrs, {radius: radius, height: width}, 'halfspace')
    transformAttrs.translation = "0 " + width + " 0"
    createX3DNode(editorId, 'cylinder', transformAttrs, {radius: radius, height: width}, 'halfspace', function(node){
      $(node).down('material').writeAttribute('diffuseColor', "1 1 0")
      return node;
    }, true)
  }
  
  function setRotationBySpherical(prefix, index, transformAttrs){
    var theta = $F(prefix + '_theta_' + index)
    var phi = $F(prefix + '_phi_' + index)
    
    transformAttrs.rotation = spherical2rotationAttribute(theta, phi)
  }
  
  function getAtomRadius(atom_type){
    return atom_dictionary[atom_type].gauss[0][0]
  }
  
  function potential4_atom(){
    var index = getIndex(this.id);
    var atom_type = $F("atom_select_" + index);
    var repeaterVec = repeaterVector(index)
    var repeaterNum = repeaterNumber(index)
    var center = centerCoords('atom', index)
    var atoms = ""
    var translation = center
    for(var i = 0; i < repeaterNum; i++){
      atoms += atom_type + " " + translation.join(' ') + NL
      translation = translation.map(function(coord, index){
        return coord + repeaterVec[index];
      });
    }
    var result = multiatomPotential(atoms)
    return result;
  }
  
  function createX3D_atom(editorId){
    var transformAttrs = {};
    
    var index = getIndex(editorId);
    var atom_type = $F("atom_select_" + index);
    var r = getAtomRadius(atom_type);
    createX3DNode(editorId, 'sphere', transformAttrs, {radius: r}, 'atom');
  }
  
  function potential4_multiatom(){
    var index = getIndex(this.id);
    
    var coordsString = $F('multiatom_coords_' + index);
    var result = multiatomPotential(coordsString.gsub(',', ' ').strip())
    return result
  }
  
  function createX3D_multiatom(editorId){
    var index = getIndex(editorId);
    
    var coordsString = $F('multiatom_coords_' + index);
    var coords = parseCSV(coordsString);
    $('multiatom_no_atoms_' + index).update(coords.length)
    
    coords.each(function(atom_spec){
      var atom_type = atom_spec[0].strip();
      var r = getAtomRadius(atom_type);
      var translation = atom_spec.slice(1).join(' ')
      renderer.addX3DNode('sphere', {translation: translation}, {radius: r});
    });
  }
  
  function addUploadedAtoms(result){
    var editorId = addBody('multiatom', false);
    var index = getIndex(editorId);
    $('multiatom_coords_' + index).value = result;
    $(editorId).createX3D();
  }
  
  function multiatomPotential(atomsString){
    var lines = []
    var atoms = atomsString.split('\n').map(function(row){
      var result = row.strip().split(' ')
      return (result.size() == 4 ? result : undefined) 
    }).compact().map(function(arr){
      return {name: arr[0], center: arr.slice(1, 4).join(' ')}
    })
    var atomTypes = atoms.map(function(atom){return atom.name}).uniq()
    var result = "atoms" + NL
    result += atomTypes.size() + NL
    atomTypes.each(function(atomType, index){
      var params = atom_dictionary[atomType].gauss.flatten()
      result += params.size() + NL
      params.each(function(param){
        result += param + NL
      })
    })
    result += atoms.size() + NL
    atoms.each(function(atom){
      result += (atomTypes.indexOf(atom.name) + 1) + " " + atom.center + NL 
    })
    return result
  }
  
  function repeaterVector(index){
    return  $w('x y z').map(function(axis){
      return (+$('repeater_' + axis + '_' + index).value);
    });
  }
  
  function repeaterNumber(index){
    return $('repeater_n_' + index).value;
  }
  
  function objectsPotentialText(editor, editorType, specificLine){
    var index = getIndex(editor.id)
    var repeaterVec = repeaterVector(index)
    var repeaterNum = repeaterNumber(index)
    var center = centerCoords(editorType, index)
    
    var theta = 0
    var thetaId = editorType + '_theta_' + index
    if($(thetaId)){
     theta = $F(thetaId) 
    }
    
    var phi = 0
    var phiId = editorType + '_phi_' + index
    if($(phiId)){
      phi = $F(phiId)
    }
    
    var v = $F(editorType + '_v_' + index)
    var result = "objects" + NL
    var translation = center
    for(var i = 0; i < repeaterNum; i++){
      result += editorType + NL
      result += translation.join(' ') + NL
      result += theta + " " + phi + NL
      result += specificLine + NL
      result += v + NL
      translation = translation.map(function(coord, index){
        return coord + repeaterVec[index];
      });
    }
    result += 'end' + NL
    return result
  }
  
  function createX3DNode(editorId, bodyType, transformAttrs, bodyAttrs, editorType, decorator){
    
    transformAttrs.id = "tr_" + editorId;
    
    var index = getIndex(transformAttrs.id);
    
    var vector = repeaterVector(index)
    
    var n = repeaterNumber(index)
    
    if(editorType === undefined){
      editorType = bodyType;
    }
    var baseTranslation = [0, 0, 0]
    if(transformAttrs.translation){
      baseTranslation = $w(transformAttrs.translation)
    }
    var translation = centerCoords(editorType, index);
  
    translation = translation.map(function (i, index){
      return i + +baseTranslation[index]
    })
  
    for(var i = 0; i < n; i++){
      var trAttrs = Object.clone(transformAttrs);
      trAttrs.translation = translation.join(" ");
      trAttrs.id += "_" + i; 
      renderer.addX3DNode(bodyType, trAttrs, bodyAttrs, decorator);
      translation = translation.map(function(coord, index){
        return coord + vector[index];
      });
    };
  }
  
  var rootParent = $('root').parentNode;
  var root = $('root')
  
  // function displaySwitch(event){
  //   var on = event.element().checked
  //   var canvas = $('x3dom-renderer-canvasdiv')
  //   if(on){
  //     
  //     //canvas.show()
  //     rebuildScene()
  //   }
  //   else{
  //     root = clearScene()
  //     //canvas.hide()
  //     
  //     
  //   }
  // }
  
  function clearScene(){
    var old_root = $('root').remove();
    root = NodeBuilder(
      ['Group', {id: 'root'}]
    )
    rootParent.appendChild(root);
    renderer.reset()
    return old_root
  }
  
  function rebuildScene(){
    clearScene()
    renderer.autoDistance = $('auto_distance_switch').checked
    $('bodies').select('table').each(function(e){
      e.createX3D();
    })
    renderer.finish()
    if(renderer.autoDistance){
      var viewPort = $('main_view')
     
      var old_position = viewPort.getAttribute('position').split(' ')
      var absolute = Math.sqrt(old_position.inject(0, function(acc, i){return acc + i*i}))
      var lambda = renderer.radius*3/absolute
    
      viewPort.setAttribute('position', old_position.map(function(i){return i*lambda;}).join(' '))
    }
  }
  
  function checkAutoDistance(event){
    if(event.element().checked){
      rebuildScene()
    }
  }

  var renderer = {
    
    //diffuseColor: "0.41 0.39 0.03",
    diffuseColor: "0.1 0.1 1",
    specularColor: "0.94 0.72 0",
    radius: 1,
    autoDistantce: true,
    
    reset: function(){
      this.radius = -1
    },
    
    finish: function(){
      if(this.radius == -1){
        this.radius = 1
      }
    },
    
    
    calcRadius_sphere: function(bodyAttrs){
      return +bodyAttrs.radius
    },
    calcRadius_box: function(bodyAttrs){
      return bodyAttrs.size.split(' ').map(function(i){return +i}).max()
    },
    calcRadius_cylinder: function(bodyAttrs){
      return [+bodyAttrs.radius, +bodyAttrs.height].max()
    },
    
    
    calcDistance: function(bodyType, transformAttrs, bodyAttrs){
      var bodyRadius = eval('this.calcRadius_' + bodyType)(bodyAttrs)
      var distance = Math.sqrt(transformAttrs.translation.split(' ').inject(0, function(acc, n){return acc + n*n}))
      var new_radius = bodyRadius + distance
      if(new_radius > this.radius){
        this.radius = new_radius
      }
    },
    
    addX3DNode: function(bodyType, transformAttrs, bodyAttrs, decorator, skipDistance){
      if(decorator === undefined){
        decorator = Prototype.K
      }
      if(this.autoDistantce && !skipDistance){
        this.calcDistance(bodyType, transformAttrs, bodyAttrs)
      }
      var bodyTypeCap = bodyType.capitalize();
      root.appendChild(
        decorator(
          NodeBuilder(
            ['Transform', transformAttrs,
              ['Shape', {},
                ['Appearance', {},
                  ['Material', {diffuseColor:this.diffuseColor , specularColor: this.specularColor, shininess: '0.12', transparency: "0.4"}]
                ],
                [bodyTypeCap, bodyAttrs]
              ]
            ]
          )
        )
      );
    }
  };

  function reindexing_bodies(){  
     var trs = [];
     $('bodies').childElements().each(function (e){
       trs.push(e);
     });
     $A(trs).each(reindexing);
   }

  function addBodyEditor(prototype_id){
    var clone = $(prototype_id + "_prototype").cloneNode(true);
    //clone.setStyle("display: none;");
    //Element.extend(clone);
    reindexing(clone, 1000001);
    $('bodies').appendChild(clone);
    reindexing_bodies();
    Effect.Appear(clone.id, { duration: 0.5 });
    //$('bodies').appendChild(new Element('hr'));
    if(prototype_id != 'multiatom'){
      $(clone.id).down('tbody').appendChild(addRepeater(clone.id));
    }
    $(clone.id).select('input, select').each(function(e){
      e.observe('change', rebuildScene);
    });
    return clone.id;
  }
  
  function addRepeater(id){
    var index = getIndex(id);
    var tr = NodeBuilder(
      ['tr', {},
        ['td', {colspan: 100}, 
          ['div', {'class': 'editor_option'}, 
            ['span', {onclick: "Effect.toggle(event.element().next())"}, 'repeat'],
            ['span', {id: 'repeater_container_' + index}, 
              ['input', {id: 'repeater_n_' + index, type: 'text', value: '1'}],
              ['span', {}, ' time(s) '],
          
              ['span', {}, 'by ['],
              ['input', {id: 'repeater_x_' + index, type: 'text', value: '0'}],
              ['span', {}, ','],
              ['input', {id: 'repeater_y_' + index, type: 'text', value: '0'}],
              ['span', {}, ','],
              ['input', {id: 'repeater_z_' + index, type: 'text', value: '0'}],
              ['span', {}, ']']
            ]
          ]
        ]
      ]
      );
    return tr;
  }
  
  function removeBody(event){
    var element = Event.element(event).up('table');
    Effect.Fade(element.id, {
      duration: 0.5, 
      afterFinish: function(){
        element.remove();
        reindexing_bodies();
        rebuildScene();
      }});
  }
  
  function buildMeshFile(){
    var content = []
    $w('x y z').each(function (item){
      content.push(("m" + item).toUpperCase() + "\t=" + $F('n' + item)/2)
    })
    $w('hr morb order estp este imsg maxim many rmul epsi epsr').each(function(item){
      var value;
      if(item == 'imsg'){
        value = 0
        $R(0, 3).each(function(bit){
          var checked = $F('imsg_' + bit) == 'on'
          if(checked){
            value |= 1 << bit
          }
        })
        if($F('many') != ''){
          value |= 16
        }
      }
      else{
        value = $F(item)
      }
      content.push(item.toUpperCase() + "=" + value)
    })
    var fileContent = content.join('\n')
    
    return fileContent
  }
  
  function buildModelFile(){
    var content = []
    $w('h2m norb').each(function(item){
      var value;
      value = $F(item)
      content.push(item.toUpperCase() + "\t=" + value)
    })    
    var fileContent = content.join('\n')
    return fileContent
  }
  

  function buildPotentialFile(){
    //fejlec 
    //elso azonosito
    var result = "Gridportal " + NL
    //masodik azonosito
    result += new Date().toString() + NL 
    //mesh
    //xyz pontok szama
    result += $w('x y z').map(function (item){
      return $F('n' + item)
    }).join(' ') + NL
    //kezdo koordinatak angst-ben TODO
    result += "0 0 0" + NL
    //a racs teljes merete angst-ben
    result += "0 0 0" + NL
    //V0
    result += $F('default')
    $('bodies').select('table').each(function(e){
      result += e.potentialText();
    })
    
    //vegjel
    result += 'end' + NL
    //lablec
    result += 'T' + NL + 'T' + NL + 'output.bin' + NL 
    return result
  }
  
  var fileName = 'f'
  
  function buildCommandArgs(){
    return "3dsch " + fileName;
  }
  

  var potentialContainer = 'bodies_panel';
  function prepareSubmit(){
  
    var meshContent = buildMeshFile();
    var modelContent = buildModelFile();
    var potentialContent;

    var result = {
      command_args: buildCommandArgs(),
      files: [
        {name: fileName + '.meshx', content: meshContent},
        {name: fileName + '.model', content: modelContent}
      ],
      potentialContainer: potentialContainer
    }
    if(potentialContainer == 'bodies_panel'){
      result.files.push({name: 'potential.txt' , content: buildPotentialFile()});
    } 
    else{
      potentialReference = $F('potential_reference')
      result.references = []
      result.references.push({name: 'potential.bin', url: potentialReference})
    }
    
    return result;
  }
  
  $('partial_form').preInit = function(settings){
    generateAtomOptions();
    var json = settings.form_data
    var editors = $H(json).keys().inject([], function(result, key){
      var match = /^([^_]+).+?_(\d+)$/.exec(key)
      if(match && match[1] != 'repeater'){
        result[match[2]] = match[1];
      }
      return result;
    });
    editors.each(function(editor_type){
      addBody(editor_type, false);
    });
    if(settings.launch_params && settings.launch_params.potentialContainer){  
      potentialContainer = settings.launch_params.potentialContainer
    }
  }
  var initialized = false;
  $('partial_form').init = function (){
    $$('.hidden_prototype').invoke('hide');
    //$$('.long_desc').invoke('hide');
    $$('input').each(function (e){
      var ph = e.readAttribute('valid_if');
      if(ph){
        e.writeAttribute('placeholder', translate4human(ph));
      }
    });
    
    new Control.Tabs('potential_tabs',{  
      beforeChange: function(old_container, new_container){
        if(!initialized || confirm('Only one kind of settings of potential is available, the other is ignored. Are you sure?')){
          potentialContainer = new_container.id
        }
        else{
          throw $break;
        }
      },
      defaultTab: potentialContainer
      
    });
    
    initialized = true
    $$('.long_desc').invoke('toggle');
    rebuildScene();
  }
  
