-#
  EMBEDDED_STYLE

    .vector3 input, #objects table input{
      max-width: 7em;
      //background: yellow;
    }
    
    th.tlabel{
      border-right: solid 1px lightgrey;
      margin-right: 50px;
      min-width: 80px;
      width: 80px;
      max-width: 80px;
      padding: 2px;
    }
    
    tr td.first_cell, tr th.first_cell{
      //background: yellow;
      padding-left: 20px; 
    }
    
    .parameter_row{
      clear: both;
      display: table-row;
    }
    
    .parameter_row .label{
      margin-right: 15px;
      color: grey;
      text-align: right;
      width: 230px;
    }
    
    .parameter_row .value{
      width: 300px;
    }
    
    #parameters.group .parameter_row a.minus{
      float: right;
      height: 1em;
      padding: 3px;
      margin-left: 5px;
      margin-top: 1px;
      margin-bottom: 1px;
    }
    
    .source_editor{
      background: #f0f0f0;
      //color: ligthgrey;
      width: 625px;
      height: 200px;
    }
    
    .sub2panel a.minus{
      margin-left: 12px;
      margin-bottom: 6px;
    }
    
    a.clickable{
      margin-left: 12px;
    }
    
    .not_alone{
      display: none;
    }
    
    
    .group_title .clickable{
      width: 15px;
      height: 15px;
      padding-top: 0px;
      float: right;
    }
    
    pre{
      font-weight: bold;
      background: url('/images/grey79.png') repeat scroll 0 0;
      -moz-border-radius: 5px 
    }
    
    .prop_row .field a.add_step{
      margin-left: 0px;
      width: 15px;
      height: 15px;
    }
    
    .prop_row .field a.step_function_minus{
      display: inline-block;
      width: 20px;
      height: 20px;
      position: relative;
      padding: 0 0 0 0;
      top: 5px;
    }
  
  EMBEDDED_STYLE



%form#partial_form.panel_in_tab
  %input{:type => "hidden", :id=>"command_args"}
  %input{:type => "hidden", :id=>"display_str"}
  %input{:type => "hidden", :id=>"file_input_ss"}
  
  .group    
    %a.clickable.edit{:onClick => "toggleEditor('editor_head')", :title => 'click to see or hide the editor'}
    .long_desc
      The following text will be inserted at the begining of the Scheme file.
    
    %textarea.source_editor{:id => 'editor_head'}
      
  #parameters.group
    .group_title
      Parameters
      %a.play.clickable
    .long_desc
      Simple name-value pairs can be given as parameters. You can use the names below in place of direct values.
    %a.clickable.add{:onclick => "newParameter()"}  
    #parameter_container
    
    
     
  #computational_cell.group 
    .group_title
      Computational cell
      %a.play.clickable
    .prop_row
      .label
        latice size
      .field.vector3
        %input{:type => "text", :id => "latice_size_x", :value => "1"}
        %input{:type => "text", :id => "latice_size_y", :value => "1"}
        %input{:type => "text", :id => "latice_size_z", :value => "1"}
      .long_desc
        The size of the computational cell in x, y, z directions. Defaults to unit lengths.
      
    .prop_row
      .label
        resolution
      .field
        %input{:type => "text", :id=>"resolution", :valid_if => ""}
      .long_desc
        Specifies the computational grid resolution, in pixels per distance unit. Defaults to 10.
        The total computational grid is resolution*lattice size.
        
    .prop_row
      .label
        k-point
      .field.vector3
        %input{:type => "text", :id=>"k_point_x"}
        %input{:type => "text", :id=>"k_point_y"}
        %input{:type => "text", :id=>"k_point_z"}
      .long_desc
        If false (the default), then the boundaries are perfect metallic (zero electric field). If a
        vector, then the boundaries are Bloch-periodic.

  #pml.group 
    .group_title
      Boundary conditions
      %a.play.clickable
    .hidden_prototype
      #pml_prototype.sub2panel
        .prop_row
          .label
            thickness
          .field
            %input{:type=>"text", :id=>"pml_thickness_prototype"}
          .long_desc
            The spatial thickness of the PML layer (which extends from the boundary towards the
            inside of the computational cell).
      
        .prop_row
          .label
            direction
          .field
            %select{:id=>"pml_direction_prototype"}
              %option{:value=>"ALL", :selected=>"true"}
                all
              %option{:value=>"X"}
                x
              %option{:value=>"Y"}
                y
              %option{:value=>"Z"}
                z
          .long_desc
            Specify the direction of the boundaries to put the PML layers next to. e.g. if X. Default
            is the special value ALL.
        .prop_row
          .label
            side
          .field
            %select{:id=>"pml_side_prototype"}
              %option{:value=>"ALL", :selected=>"true"}
                all
              %option{:value=>"Low"}
                low
              %option{:value=>"High"}
                high
          .long_desc
            Specify which side, Low or High of the boundary or boundaries to put PML.
        .prop_row
          .label
            strength
          .field
            %input{:type=>"text", :id=>"strength_prototype", :value=>"1"}
          .long_desc
            A strength (default is 1.0) to multiply the PML absorption coefficient by. A strength of
            2.0 will square the theoretical asymptotic reflection coefficient of the PML
      
        .prop_row
          .label
            R-asymptotic
          .field
            %input{:type=>"text", :id=>"r_asymptotic_prototype", :value=>"1e-15"}
          .long_desc
            The asymptotic reflection in the limit of infinite resolution or infinite PML thickness,
            for refections from air.
      
        .prop_row
          .label
            pml-profile
          .field
            %input{:type=>"text", :id=>"pml_profile_prototype"}
          .long_desc
            With pml-profile one can specify an arbitrary PML "profile" function f(u) that
            determines the shape of the PML absorption profile
        %a.minus.clickable{:onClick => "removeSub2panel(event);"}
    #pml_container 
    %a.clickable.add{:onclick => "newSub2panel('pml')"} 
        
  #symmetry.group 
    .group_title
      Symmetry
      %a.play.clickable
    .prop_row
      .label
        add
      #add_symmetry_buttons.field
        %a.action_link.button_like{:onClick => "newSymmetry('mirror-sym');"}
          mirror
        %a.action_link.button_like{:onClick => "newSymmetry('rotate2-sym');"}
          180&deg; rotational
        %a.action_link.button_like{:onClick => "newSymmetry('rotate4-sym');"}
          90&deg; rotational
      .long_desc
        %dl
          %dt 
            mirror
          %dd
            A mirror symmetry plane. Here, the direction is the direction normal to the mirror
            plane.
          %dt
            180&deg; rotational
          %dd
            A 180° (twofold) rotational symmetry (a.k.a. C2). Here, the direction is the axis of the
            rotation.
          %dt
            90&deg; rotational
          %dd
            A 90° (fourfold) rotational symmetry (a.k.a. C4). Here, the direction is the axis of the
            rotation.
        
    %table
      %tbody#symmetry_container
        %tr.not_alone
          %th
            type
          %th
            direction
            .long_desc
              The direction of the symmetry (the normal to a mirror plane or the axis for a
              rotational symmetry).
          %th
            phase
            .long_desc
              An additional phase to multiply the fields by when operating the symmetry on them;
              defaults to 1.0.
          %th
          
  #materials.group
    .group_title
      Materials
      %a.play.clickable
    .prop_row
      .label
        add medium with 
      .field
        %a.action_link.button_like{:onclick => "newSub2panel('epsilon', 'material')"}
          dielectric constant
        %a.action_link.button_like{:onclick => "newSub2panel('index', 'material')"}
          refractive index
    .hidden_prototype
      #epsilon_prototype.sub2panel
        .prop_row
          .label
            name
          .field
            %input{:type => 'text', :id => 'material_name_prototype'}
          .long_desc
            Name of the material.
        .prop_row
          .label
            epsilon
          .field
            %input{:type => 'text', :id => 'material_epsilon_prototype'}
          .long_desc
            The (frequency-independent) isotropic relative permittivity, or dielectric constant.
        %a.minus.clickable{:onClick => "removeSub2panel(event);"}
      #index_prototype.sub2panel
        .prop_row
          .label
            name
          .field
            %input{:type => 'text', :id => 'material_name_prototype'}
          .long_desc
            Name of the material.
        .prop_row
          .label
            index
          .field
            %input{:type => 'text', :id => 'material_index_prototype'}
          .long_desc
            The (frequency-independent) isotropic refractive index.
        %a.minus.clickable{:onClick => "removeSub2panel(event);"}
    #material_container
  
            
  #geometry.group
    .group_title
      Geometry
      %a.play.clickable
    .prop_row
      .label
        add
      .field
        -%w"sphere cylinder cone block ellipsoid".each do |item|
          %a.action_link.button_like{:onClick => "newObject('#{item}')"}
            =item
      .long_desc
        Put geometrical objects to the computational cell.
    #objects
    .prop_row.hidden_prototype 
      #sphere_prototype.sub2panel
        .sub2panel_title
          sphere
        .prop_row
          .label
            material
          .field
            %input{:type => 'text', :id => 'sphere_material_prototype'}
          .long_desc
            The name of the material that the object is made of, defined in the materials section.
        .prop_row
          .label
            center
          .field.vector3
            %input{:type => 'text', :id => 'sphere_centerx_prototype', :value => '0'}
            %input{:type => 'text', :id => 'sphere_centery_prototype', :value => '0'}
            %input{:type => 'text', :id => 'sphere_centerz_prototype', :value => '0'}
          .long_desc
            Center point of the object.
          
        .prop_row
          .label
            radius
          .field
            %input{:type => 'text', :id => 'sphere_radius_prototype', :value => '1'}
          .long_desc
            Radius of the sphere.

        
        %a.minus.clickable{:onClick => "removeSub2panel(event);"}


      #cylinder_prototype.sub2panel
        .sub2panel_title
          cylinder
        .long_desc
          A cylinder, with circular cross-section and finite height.
        .prop_row
          .label
            material
          .field
            %input{:type => 'text', :id => 'cylinder_material_prototype'}
          .long_desc
            The name of the material that the object is made of, defined in the materials section.
        .prop_row
          .label
            center
          .field.vector3
            %input{:type => 'text', :id => 'cylinder_centerx_prototype', :value => '0'}
            %input{:type => 'text', :id => 'cylinder_centery_prototype', :value => '0'}
            %input{:type => 'text', :id => 'cylinder_centerz_prototype', :value => '0'}
          .long_desc
            Center point of the object.
        .prop_row
          .label
            radius
          .field
            %input{:type => 'text', :id => 'cylinder_radius_prototype', :value => '1'}
          .long_desc
            Radius of the cylinder's cross-section.
            
        .prop_row
          .label
            height
          .field
            %input{:type => 'text', :id => 'cylinder_height_prototype', :value => '2'}
          .long_desc
            Length of the cylinder along its axis.
        
        .prop_row
          .label
            axis
          .field.vector3
            %input{:type => 'text', :id => 'cylinder_axisx_prototype', :value => '0'}
            %input{:type => 'text', :id => 'cylinder_axisy_prototype', :value => '0'}
            %input{:type => 'text', :id => 'cylinder_axisz_prototype', :value => '0'}
          .long_desc
            Direction of the cylinder's axis; the length of this vector is ignored. Defaults to point
            parallel to the z axis.

        %a.minus.clickable{:onClick => "removeSub2panel(event);"}
              
      #cone_prototype.sub2panel
        .sub2panel_title
          cone
        .prop_row
          .label
            material
          .field
            %input{:type => 'text', :id => 'cone_material_prototype'}
          .long_desc
            The name of the material that the object is made of, defined in the materials section.
        .prop_row
          .label
            center
          .field.vector3
            %input{:type => 'text', :id => 'cone_centerx_prototype', :value => '0'}
            %input{:type => 'text', :id => 'cone_centery_prototype', :value => '0'}
            %input{:type => 'text', :id => 'cone_centerz_prototype', :value => '0'}
          .long_desc
            Center point of the object.
        .prop_row
          .label
            radius
          .field
            %input{:type => 'text', :id => 'cone_radius_prototype', :value => '1'}
          .long_desc
            Radius of the base of the cone.
        .prop_row
          .label
            height
          .field
            %input{:type => 'text', :id => 'cone_height_prototype', :value => '2'}
          .long_desc
            Length of the cone along its axis.
        .prop_row
          .label
            axis
          .field.vector3
            %input{:type => 'text', :id => 'cone_axisx_prototype', :value => '0'}
            %input{:type => 'text', :id => 'cone_axisy_prototype', :value => '0'}
            %input{:type => 'text', :id => 'cone_axisz_prototype', :value => '0'}
          .long_desc
            Direction of the cone's axis; the length of this vector is ignored. Defaults to point
            parallel to the z axis.
        .prop_row
          .label
            radius2
          .field
            %input{:type => 'text', :id => 'cone_radius2_prototype', :value => '0'}
          .long_desc
            Radius of the tip of the cone (i.e. the end of the cone pointed to by the axis vector).
            Defaults to zero (a "sharp" cone).
          
        %a.minus.clickable{:onClick => "removeSub2panel(event);"}        

              
      #block_prototype.sub2panel
        .sub2panel_title
          block
        .long_desc
          A parallelepiped (i.e., a brick, possibly with non-orthogonal axes).
        .prop_row
          .label
            material
          .field
            %input{:type => 'text', :id => 'block_material_prototype'}
          .long_desc
            The name of the material that the object is made of, defined in the materials section.
        .prop_row
          .label
            center
          .field.vector3
            %input{:type => 'text', :id => 'block_centerx_prototype', :value => '0'}
            %input{:type => 'text', :id => 'block_centery_prototype', :value => '0'}
            %input{:type => 'text', :id => 'block_centerz_prototype', :value => '0'}
          .long_desc
            Center point of the object.
        .prop_row
          .label
            size
          .field.vector3
            %input{:type => 'text', :id => 'block_sizex_prototype', :value => '1'}
            %input{:type => 'text', :id => 'block_sizey_prototype', :value => '1'}
            %input{:type => 'text', :id => 'block_sizez_prototype', :value => '1'}
          .long_desc
            The lengths of the block edges along each of its three axes.
        .prop_row
          .label
            %span<
              axis
            %sub<>
              1
          .field.vector3
            %input{:type => 'text', :id => 'block_axis1x_prototype', :value => '1'}
            %input{:type => 'text', :id => 'block_axis1y_prototype', :value => '1'}
            %input{:type => 'text', :id => 'block_axis1z_prototype', :value => '1'}
            
        .prop_row
          .label
            %span<
              axis
            %sub<>
              2
          .field.vector3
            %input{:type => 'text', :id => 'block_axis2x_prototype', :value => '1'}
            %input{:type => 'text', :id => 'block_axis2y_prototype', :value => '1'}
            %input{:type => 'text', :id => 'block_axis2z_prototype', :value => '1'}


        .prop_row
          .label
            %span<
              axis
            %sub<>
              3
          .field.vector3
            %input{:type => 'text', :id => 'block_axis3x_prototype', :value => '1'}
            %input{:type => 'text', :id => 'block_axis3y_prototype', :value => '1'}
            %input{:type => 'text', :id => 'block_axis3z_prototype', :value => '1'}
        .long_desc
          The directions of the axes of the block; the lengths of these vectors are ignored. Must
          be linearly independent. They default to the three lattice directions.
            
        %a.minus.clickable{:onClick => "removeSub2panel(event);"}      
              
      #ellipsoid_prototype.sub2panel
        .sub2panel_title
          ellipsoid
        .prop_row
          .label
            material
          .field
            %input{:type => 'text', :id => 'ellipsoid_material_prototype'}
          .long_desc
            The name of the material that the object is made of, defined in the materials section.
        .prop_row
          .label
            center
          .field.vector3
            %input{:type => 'text', :id => 'ellipsoid_centerx_prototype', :value => '0'}
            %input{:type => 'text', :id => 'ellipsoid_centery_prototype', :value => '0'}
            %input{:type => 'text', :id => 'ellipsoid_centerz_prototype', :value => '0'}
          .long_desc
            Center point of the object.
        .prop_row
          .label
            size
          .field.vector3
            %input{:type => 'text', :id => 'ellipsoid_sizex_prototype', :value => '1'}
            %input{:type => 'text', :id => 'ellipsoid_sizey_prototype', :value => '1'}
            %input{:type => 'text', :id => 'ellipsoid_sizez_prototype', :value => '1'}
          .long_desc
            The lengths of the block edges along each of its three axes.
        .prop_row
          .label
            %span<
              axis
            %sub<>
              1
          .field.vector3
            %input{:type => 'text', :id => 'ellipsoid_axis1x_prototype', :value => '1'}
            %input{:type => 'text', :id => 'ellipsoid_axis1y_prototype', :value => '1'}
            %input{:type => 'text', :id => 'ellipsoid_axis1z_prototype', :value => '1'}

        .prop_row
          .label
            %span<
              axis
            %sub<>
              2
          .field.vector3
            %input{:type => 'text', :id => 'ellipsoid_axis2x_prototype', :value => '1'}
            %input{:type => 'text', :id => 'ellipsoid_axis2y_prototype', :value => '1'}
            %input{:type => 'text', :id => 'ellipsoid_axis2z_prototype', :value => '1'}


        .prop_row
          .label
            %span<
              axis
            %sub<>
              3
          .field.vector3
            %input{:type => 'text', :id => 'ellipsoid_axis3x_prototype', :value => '1'}
            %input{:type => 'text', :id => 'ellipsoid_axis3y_prototype', :value => '1'}
            %input{:type => 'text', :id => 'ellipsoid_axis3z_prototype', :value => '1'}
          .long_desc
            The directions of the axes of the block; the lengths of these vectors are ignored. Must
            be linearly independent. They default to the three lattice directions.

        %a.minus.clickable{:onClick => "removeSub2panel(event);"}              

          
  
  #source.group
    .group_title
      Source
      %a.play.clickable
    .long_desc
      Specify sources in the computational area.
    .hidden_prototype
      #source_prototype.sub2panel
        .prop_row
          .label
            source type
          .field
            %input{:type => "radio", :name => "source_type_prototype", :value => 'continuous', :id => "source_type_continuous_prototype", :checked => "true"}
              continuous
            %input{:type => "radio", :name => "source_type_prototype", :value => 'gaussian', :id => "source_type_gaussian_prototype"}
              gaussian
            %input{:type => "radio", :name => "source_type_prototype",:value => 'custom'  ,:id => "source_type_custom_prototype"}
              custom
          .long_desc
            %dl
              %dt
                continuous:
              %dd 
                A continuous-wave source proportional to exp( iωt), possibly with a
                smooth (exponential/tanh) turn-on/turn-off.
              %dt
                gaussian: 
              %dd
                \ A Gaussian-pulse source roughly proportional to exp( iωt (t - t<sub>0</sub>)<sup>2</sup> / 2w<sup>2</sup>).
              %dt
                custom: 
              %dd
                A user-specified source function f(t).
        .source_fields
          .prop_row.continuous.gaussian
            .label
              frequency
            .field
              %input{:type => "text", :id => "source_frequency_prototype"}
            .long_desc
              .continuous
                Frequency of the source.
            .long_desc
              .gaussian
                The center frequency f in units of c/distance (or ω in units of 2πc/distance)
          .prop_row.continuous.gaussian.custom
            .label
              start-time
            .field
              %input{:type => "text", :id => "source_start_time_prototype"}
            .long_desc
              .continuous.gaussian
                The starting time for the source; default is 0 (turn on at t = 0).
              .custom
                The starting time for the source.
              
          .prop_row.continuous.custom
            .label
              end-time
            .field
              %input{:type => "text", :id => "source_end_time_prototype"}
            .long_desc
              .continuous.custom
                The end time for the source; default is infinity (never turn off).
          .prop_row.continuous.gaussian
            .label
              width
            .field
              %input{:type => "text", :id => "source_width_prototype"}
            .long_desc
              .continuous
                Roughly, the temporal width of the smoothing (technically, the inverse of the
                exponential rate at which the current turns off and on).
              .gaussian
                The width w used in the Gaussian.
          .prop_row.continuous.gaussian
            .label
              cutoff
            .field
              %input{:type => "text", :id => "source_cutoff_prototype"}
            .long_desc
              .continuous
                How many widths the current decays for before we cut it off and set it to zero; the
                default is 3.0.
            .long_desc
              .gaussian
                How many widths the current decays for before we cut it off and set it to zero—this
                applies for both turn-on and turn-off of the pulse. The default is 5.0.
          .prop_row.custom
            .label
              src-func
            .field
              %input{:type => "text", :id => "source_src_func_prototype"}
            .long_desc
              .custom
                The function f(t) specifying the time-dependence of the source.
        .others      
          .prop_row
            .label
              component
            .field
              %input{:type => "text", :id => "source_component_prototype"}
            .long_desc
              Specify the direction and type of the current component: e.g. Ex, Ey.
            
          .prop_row
            .label
              center
            .field.vector3
              %input{:type => "text", :id => "source_centerx_prototype"}
              %input{:type => "text", :id => "source_centery_prototype"}
              %input{:type => "text", :id => "source_centerz_prototype"}
            .long_desc
              The location of the center of the current source in the computational cell.
          .prop_row
            .label
              size
            .field.vector3
              %input{:type => "text", :id => "source_sizex_prototype"}
              %input{:type => "text", :id => "source_sizey_prototype"}
              %input{:type => "text", :id => "source_sizez_prototype"}
            .long_desc
              The size of the current distribution along each direction of the computational cell.
          .prop_row
            .label
              amplitude
            .field
              %input{:type => "text", :id => "source_amplitude_prototype"}
            .long_desc
              An overall (complex) amplitude multiplying the the current source. Default is 1.0.
          .prop_row
            .label{:name => 'amp-func'}
              amplitude function
            .field
              %input{:type => "text", :id => "source_amp_func_prototype"}
            .long_desc
              Scheme function of a single argument, that takes a vector3 giving a position and
              returns a (complex) current amplitude for that point.

        %a.minus.clickable{:onClick => "removeSub2panel(event);"}      
        
    #source_container
    .prop_row
      %a.clickable.add{:onclick => "newSource('source')"}   


  #flux.group
    .group_title
      Flux region
      %a.play.clickable
    .long_desc
      Specify a region to compute the integral of the Poynting vector of the Fourier-
      transformed fields.
    .hidden_prototype
      #flux_prototype.sub2panel
        .prop_row
          .label
            center
          .field.vector3
            %input{:type => "text", :id => "flux_centerx_prototype"}
            %input{:type => "text", :id => "flux_centery_prototype"}
            %input{:type => "text", :id => "flux_centerz_prototype"}
          .long_desc
            The center of the flux region.
        .prop_row
          .label
            size
          .field.vector3
            %input{:type => "text", :id => "flux_sizex_prototype"}
            %input{:type => "text", :id => "flux_sizey_prototype"}
            %input{:type => "text", :id => "flux_sizez_prototype"}
          .long_desc
            The size of the flux region along each of the coordinate axes.
        .prop_row
          .label
            direction
          .field
            %input{:type => "text", :id => "flux_direction_prototype"}
          .long_desc
            The direction in which to compute the flux.
        .prop_row
          .label
            weight
          .field
            %input{:type => "text", :id => "flux_weight_prototype"}
          .long_desc
            A weight factor to multiply the flux by when it is computed; default is 1.0.
        .prop_row
          .label
            frequency center
          .field
            %input{:type => "text", :id => "flux_fcen_prototype"}
          .long_desc
            The center of the frequency range, which computed.
        
        .prop_row
          .label
            frequency width
          .field
            %input{:type => "text", :id => "flux_df_prototype"}
          .long_desc
            The width of the frequncy range.
            
        .prop_row
          .label
            number of frequencies
          .field
            %input{:type => "text", :id => "flux_nfreq_prototype"} 
          .long_desc
            The discrete number of frequencies within the frequncy range.
        %a.minus.clickable{:onClick => "removeSub2panel(event);"}      
    
    #flux_container
    %a.clickable.add{:onclick => "newSub2panel('flux')"} 
      
  #run.group
    .group_title
      Running parameters
      %a.play.clickable
    .prop_row
      .label
        run type
      .field
        %input{:type => "radio", :name => "run_type", :value => 'until', :id => "run_type_until", :checked => "true"}
          until
        %input{:type => "radio", :name => "run_type", :value => 'sources', :id => "run_type_sources"}
          sources
      .long_desc
        %dl
          %dt
            until: 
          %dd
            Run the simulation until a certain time or condition, calling the given step
            functions (if any) at each timestep.
          %dt
            sources: 
          %dd
            Run the simulation until all sources have turned off, calling the given step
            functions (if any) at each timestep.
   
    .prop_row
      .label
        cond?/time
      .field
        %input{:type => "text", :id => "run_cond"}
      .long_desc
        Either a number, in which case it is an additional time (in Meep units) to run for, or it
        is a function (of no arguments) which returns true when the simulation should stop.
    
    .prop_row
      .label
        step functions
      .field
        %a.clickable.add.add_step{:onclick => "newStepFunction()"}
      .long_desc
        Define Scheme codes to calculate in the run time.
    #step_function_container
    .prop_row
      .label
        &nbsp;
      .field
         
    .prop_row
      .label
        output epsilon
      .field
        %input{:type => "checkbox", :id => "run_output_epsilon"}
      .long_desc
        Output the dielectric field within the computational cell.

       
  .group    
    %a.clickable.edit{:onClick => "toggleEditor('editor_tail')", :title => 'click to see or hide the editor'}
    .long_desc
      The following text will be inserted at the end of the Scheme file.

    %textarea.source_editor{:id => 'editor_tail'}
  %br 
  


      
:javascript
  Object.extend(String.prototype, {
    nl: function(){
      if(this != ''){
        return this + "\n"
      }
      else{
        return this
      }
    },
    prefix: function(prefix){
      if(this != ''){
        return prefix + this
      }
      else{
        return this
      }
    }
  })
 
  function lisp(){
    var args = $A(arguments);
    var result = "(";
    result += args.without('').join(' ')
    result += ")"
    return result;
  }
  
  function L(){
    var args = $A(arguments)
    if(args.all(function(arg){
      return arg !== undefined && arg.strip() != ''
    })){
      return lisp.apply(null, args)
    }
    else{
      return ""
    }
  }
  
  function V(id){
    var element = $(id)
    if(element){
      if(element.value !== undefined){
        return element.value
      }
      else{
        throw 'no value property:' + id 
      }
    }
    else{
      throw 'wrong id:' + id
    }
  }
  
  function T(element){
    return Element.collectTextNodes(element).strip()
  }
  
  function row2Lisp(row, prefix, index){
    var labelDiv = row.down('.label')
    var name = labelDiv.readAttribute('name') || T(labelDiv)
    var label = name.gsub('-', '_')
    var fieldElement = row.down('.field')
    var value;
    if(fieldElement.hasClassName('vector3')){
      value = vector3([prefix, label + "XYZ", index].join('_'))
    }
    else{
      value = V([prefix, label, index].join('_'))
    }
    return L(name, value)
  }
  
  function vector3(idTemplate){
    var defined = true;
    var result = $w('x y z').map(function(c){
      var id = idTemplate.gsub('XYZ', c)
      var val = V(id)
      if(val == ''){
        defined = false
      }
      return val;  
    }).join(' ')
    if(defined){
      return result
    }
    else{
      return ""
    }
  }

  var generators = {
    parameters: function(){
      var result = ""
      $$('#parameter_container div').each(function(row){
        var label = row.down('.label').value
        var value = row.down('.value').value
        var def;
        if(isNumber(value)){
          def = "define-param"
        }
        else{
          def = "define"
        }
        result += L(def, label, value).nl()
      })
      return result;
    },
    computational_cell: function(){
      var result = '';
      result += L('set! geometry-lattice', L('make lattice', L('size', vector3('latice_size_XYZ')))).nl()
      result += L('set! resolution', V('resolution')).nl()
      result += L('set-param! k-point', L('vector3', vector3('k_point_XYZ'))).nl()
      return result;
    },
    pml: function(){
      var result = ''
      $$('#pml_container .sub2panel').each(function(element, index){
        result += "\n  " + lisp('make pml', 
          L('thickness', V('pml_thickness_' + index)), 
          L('direction', V('pml_direction_' + index)), 
          L('side', V('pml_side_' + index)), 
          L('strength', V('strength_' + index)), 
          L('R-asymptotic', V('r_asymptotic_' + index)),
          L('pml-profile', V('pml_profile_' + index)))
      })
      result = L('set! pml-layers', L('list', result))
      return result
    },
    symmetry: function(){
      var result = ''
      $$('#symmetry_container tr[id^=sym_]').each(function(tr, index){
        
        result += "\n" +
          L('make', V('sym_type_' + index), 
            L('direction', V('sym_direction_' + index)), 
            L('phase', V('sym_phase_' + index)));
      })
      result = L('set! symmetries', L('list', result))
      return result;
    },
    materials: function(){
      var result = ''
      $$('#material_container .sub2panel').each(function(panel, index){
        var type = panel.id.split('_')[0]
        result += "\n" +
          L('define', V('material_name_' + index), L('make medium', 
            L(type, V('material_' + type + '_' + index))));
      })
      
      return result;
    },
    geometry: function(){
      var result = ''
      $$('#objects .sub2panel').each(function(element, index){
        var type = T(element.down('.sub2panel_title'))
        var attrResults= []
        element.select('.prop_row').each(function(row){
          attrResults.push(row2Lisp  (row, type, index))
        })
        result += "\n" + L('make', type, attrResults.without('').join(' '))
      })
      result = L('set! geometry', L('list', result))
      return result
    },
    source: function(){
      var result = ''
      $$('#source_container .sub2panel').each(function(panel){
        var index = getIndex(panel.id)
        var source_type = radio_value('source_type_' + index)
        var src_result = ''
        panel.select('.source_fields .' + source_type).each(function(row){
          src_result += row2Lisp(row, 'source', index)
        })
        panel_result = L('src', L('make', source_type + '-src', src_result)).prefix("\n\t\t")
        panel.select('.others .prop_row').each(function(row){
          if(!row.down('input').id.startsWith('source_type')){
            panel_result += row2Lisp(row, 'source', index).prefix("\n\t\t")
          }
        })
        result += L('make source', panel_result).prefix("\n\t")
      })
      result = L('!set sources', L('list', result))
      return result.strip()
    },
    flux: function(){
      var result = ''
      var flux_names = []
      $$('#flux_container .sub2panel').each(function(panel){
        var index = getIndex(panel.id)
        var flux_name = 'flux' + index
        flux_names.push(flux_name)
        result += L('define', flux_name, L('add-flux', V('flux_fcen_' + index), V('flux_df_' + index), V('flux_nfreq_' + index), 
          L('make flux-region', L('center', vector3('flux_centerXYZ_' + index)), L('size', vector3('flux_sizeXYZ_' +index))
        ))).nl()
      })
      result += L('display-fluxes', flux_names.join(' '))
      return result;
    },
    run: function(){
      var result = []
      var run_type = radio_value('run_type')
      var condition = V('run_cond')

      
      result.push(condition)
      
      if($('run_output_epsilon').checked){
        result.push('(at-beginning output-epsilon)')
      }
      $$('#step_function_container input').each(function(input){
        result.push(V(input.id))
      })
      
      if(condition && run_type == 'sources'){
        run_type += '+'
      }
      result = L('run-' + run_type, result.join(' '))
      return result
    }
  }
  
  //end of generators

  $$('.group_title .play').each(function (e){
    e.observe('mouseover', function(event){
      showCode(event)
    })
    e.observe('mouseout', function(event){
      hideCode(event)
    })
  })

  function showCode(event){
    var panel = event.element().up('.group')
    var content = generators[panel.id]();
    //alert(content)
    //panel.setStyle("border: solid")
    var offset = panel.cumulativeOffset()
    panel.appendChild(NodeBuilder(
      ['pre', {'class': 'code', style: 'position: absolute; left: ' + 10  + 'px; top: ' +  (offset[1] + 20) + 'px'}, content]
    ))
  }
  
  function hideCode(event){
    event.element().up('.group').down('.code').remove()
  }

  var animationDuration = 0.3;
  function openAnimation(element, finishFunction){
    var finishFunctionOrNope = finishFunction || Prototype.K
    if(element.tagName.toUpperCase() == 'TR'){
      element.appear({queue: 'end', duration: animationDuration, afterFinish: finishFunctionOrNope})
    }
    else{
      element.blindDown({queue: 'end', duration: animationDuration, afterFinish: finishFunctionOrNope})
    }
    return element
  } 
  
  function closeAnimation(element, finishFunction){
    var finishFunctionOrNope = finishFunction || Prototype.K
    if(element.tagName.toUpperCase() == 'TR'){
      element.fade({queue: 'end', duration: animationDuration, afterFinish: finishFunctionOrNope})
    }
    else{
      element.blindUp({queue: 'end', duration: animationDuration, afterFinish: finishFunctionOrNope})
    }
    return element;
  }
  
  function toggleEditor(id){
    var options = {queue: 'end', duration: animationDuration}
    var toggle = true
    if($(id).visible()){
      if($(id).value != ''){
        confirm_dialog('confirm', 'The content will also be deleted', function(){
          $(id).value = '';
          $(id).blindUp(options)
        });
      }
      else{
        $(id).blindUp(options)
      }
    }
    else{
      $(id).blindDown({queue: 'end', duration: animationDuration})
    }
  }
  
  function builderInfo(function_id, container_prefix, index, params){
    var params_string = (params ? params.join(' ') : '')
    return ["input", {type: 'hidden', id: ['builder_info', function_id, container_prefix, index].join('_'), value: params_string }]
  }
  
  function addBuilderInfoNode(node, function_id, container_prefix, index, params){
    node.down('input').insert({after: NodeBuilder(builderInfo(function_id, container_prefix, index, params))})
    return node
  }
  
  function newParameter(){
    var index = $('parameter_container').childElements().size()
    openAnimation($('parameter_container').appendChild(
      NodeBuilder(
        ["div", {'class': 'parameter_row', id: 'parameter_' + index},
          ["input", {type: "text" , 'class': 'label', id: "parameter_name_" + index}],
          builderInfo('newParameter', 'parameter', index),
          ["input", {type: "text", 'class': 'value', id: "parameter_value_" + index}],
          ["a", {'class': 'clickable minus', onclick: "removeParameter(event)"}]
        ]
      )
    ).setStyle("display:none"))
  }
  
  function removeParameter(event){
    var container = event.element().up('#parameter_container')
    event.element().up('div').remove();
    reindexing_selected_children(container, "div[id^='parameter_']")
  }

  function newSymmetry(sym_type){
    var index = $('symmetry_container').childElements().size() - 1
    var label = T($('add_symmetry_buttons').down('a[onclick*=' + sym_type + ']'))
    openAnimation($('symmetry_container').appendChild(
      NodeBuilder(
        ["tr", {id: 'sym_' + index},
          ["td", {},
            ["input", {type: 'hidden', id: 'sym_type_' + index, value: sym_type}],
            builderInfo('newSymmetry', 'symmetry', index, [sym_type]),
            label
          ],
          ["td", {},
            ['input', {type: 'text', id: 'sym_direction_' + index}]
          ],
          ["td", {},
            ['input', {type: 'text', id: 'sym_phase_' + index}]
          ],
          ["td", {}, 
            ['a', { 'class': 'minus clickable', onClick: "removeRow(event, 'sym');"}]
          ]
        ]
      )
    ).setStyle("display:none")).previous().removeClassName('not_alone')
  }
  
  function removeRow(event, prefix){
    var row = event.element().up('tr')
    closeAnimation(row, function(){
      var container = event.element().up('tbody')
      row.remove();
      reindexing_selected_children(container, "tr[id^='" + prefix + "_']")
      if(container.childElements().size() == 1){
        container.firstDescendant().addClassName('not_alone')
      }
    })
    
  }
  
  function newObject(object_type){
    var prototype_id = object_type;
    var clone = $(prototype_id + "_prototype").cloneNode(true);
    var index = $('objects').childElements().size();
    addBuilderInfoNode(clone, 'newObject', 'object', index, [object_type])
    reindexing(clone, 1000001);
    $('objects').appendChild(clone).setStyle("display: none");
    reindexing(clone, index);
    openAnimation(clone);
    return clone.id;
  }
  
  
  function checkSourceSubclasses(container_id){
    var index = getIndex(container_id)
    var source_type = radio_value('source_type_' + index) 
    if(!source_type){
      source_type = 'continuous'
      $('source_type_continuous_' + index).checked = true
    }
    $(container_id).select(".source_fields .prop_row, .long_desc div").each(function(e){
      if(e.hasClassName(source_type)){
        if(!e.visible()){
          e.show()
        }
      }
      else{
        if(e.visible()){
          e.hide()
        }
      }
    }) 
  }
  
  function newSource(){
    var clone = newSub2panel('source', 'source', 'skipBuilderNode');
    addBuilderInfoNode(clone, 'newSource', 'source', getIndex(clone.id))
    checkSourceSubclasses(clone.id)

    $(clone.id).select('input[type="radio"]').each(function(e){
      e.observe('change', function(event){
        checkSourceSubclasses(event.element().up('.sub2panel').id)
      });
    });
    return clone.id;
  }  
  
  function newSub2panel(prototype_prefix, container_prefix, hint){
    var clone = $(prototype_prefix + "_prototype").cloneNode(true);
    if(!container_prefix){
      container_prefix = prototype_prefix
    }
    var container = $(container_prefix + '_container');
    var index = container.select('.sub2panel').size();
    if(hint != 'skipBuilderNode'){
      var params = $A(arguments)
      addBuilderInfoNode(clone, 'newSub2panel', container_prefix, index, params)
    }
    reindexing(clone, 'transition');
    clone.setStyle('display: none');
    container.appendChild(clone);
    reindexing(clone, index);
    //Effect.BlindDown(clone.id, { duration: 0.5 });
    openAnimation(clone)
    return clone;    
  }
  
  function removeSub2panel(event){
    var container = event.element().up('.sub2panel').parentNode;
    Effect.BlindUp(event.element().up(".sub2panel"), {afterFinish: function(){
      event.element().up('.sub2panel').remove();
      reindexing_selected_children(container, "sub2panel")
    },
    duration: 0.5})
  }
  
  function newStepFunction(){
    var index = $('step_function_container').childElements().size()
    openAnimation($('step_function_container').appendChild(
      NodeBuilder(
        ["div", {'class': 'prop_row'},
          ["div", {'class': 'label'}, "\u00a0"],
          ['div', {'class': 'field'},
            ["input", {type: "text", id: "step_function_" + index}],
            builderInfo('newStepFunction', 'step_function', index),
            ["a", {'class': 'clickable minus step_function_minus', onclick: "removeStepFunction(event)"}]
          ]
        ]
      )
    ).setStyle("display:none"))
  }

  function removeStepFunction(event){
    var container = event.element().up('#step_function_container')
    event.element().up('.prop_row').remove();
    reindexing_selected_children(container, ".prop_row")
  }
  
  function generateFile(){
    var result = V('editor_head').nl()
    $$('#partial_form > div').each(function(div){
      if(div.id){
        result += generators[div.id].call().nl()
      }
    })
    result += V('editor_tail')
    return result 
  }

  function file_upload(result){
    //alert(result);
    if(result !== ''){
      //
    }
  }


  function buildCommandArgs(){
    return "meep input.ss";
  }
  
  
  function addAccordionDynamism(){
    $$(".group .group_title").each(function(e){
      e.observe("click", function(event){
      event.element().siblings().each(function(item){
        item.toggle()
      })
    })
    })
  }


  function prepareSubmit(){
    var result = {
      command_args: buildCommandArgs(),
      files: [
        {name: 'input_ss', content: generateFile()}
      ]
    }
    
  }
  
  var functions = $w('newParameter newSymmetry newObject newSource newSub2panel newStepFunction').inject($H(), function(set, item){
    set.set(item, 1)
    return set
  })
  
  $('partial_form').preInit = function(settings){
    var json = settings.form_data;
    var functionCalls = $H()
    $H(json).each(function(pair){
      var match = /^builder_info_([^_]+)_.+([^_]+)$/.exec(pair.key)
      if(match){
        var function_id = match[1];
        var values = pair.value
        if(!Object.isArray(values)){
          values = [values]
        }
        values.each(function(value){
          (functionCalls.get(function_id) || functionCalls.set(function_id, [])).push({index: +match[2], params: value})
        })  
      }
    });
    functionCalls.each(function (pair){
      if(!functions.get(pair.key)){
        //unknown function
      }
      else{
        pair.value.sortBy(function(item){return item.index}).each(function (item){
          eval(pair.key).apply(null, item.params.split(' ') || [])
        })
      }   
    })
  }

  $('partial_form').init = function (){
    $$('.hidden_prototype').invoke('hide');
    $$('input').each(function (e){
      var ph = e.readAttribute('valid_if');
      if(ph){
        e.writeAttribute('placeholder', translate4human(ph));
      }
    });
    
    $$('.long_desc, .source_editor').invoke('hide');
    
    $('source_container').select('.sub2panel').each(function(panel){
      checkSourceSubclasses(panel.id)
    })
    
    //addAccordionDynamism();
  }
  

